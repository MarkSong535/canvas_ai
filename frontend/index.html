<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas AI Client</title>
    
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 4. Day.js (Antd Dependency) -->
    <script src="https://unpkg.com/dayjs@1/dayjs.min.js"></script>
    
    <!-- 5. Ant Design (JS & CSS) -->
    <script src="https://unpkg.com/antd@5/dist/antd.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/antd@5/dist/reset.css" />

    <style>
        /* Basic body styling */
        body {
            background-color: #f0f2f5;
        }
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #000;
            }
        }
    </style>
</head>
<body>
    <div id="root" class="h-screen"></div>

    <script type="text/babel">
        // Babel will transpile all code within this script tag

        const {
            Button,
            Card,
            Checkbox,
            Col,
            Collapse,
            ConfigProvider,
            Form,
            Input,
            Layout,
            Modal,
            Row,
            Space,
            Spin,
            Tag,
            Typography,
            App: AntApp, // Renamed to avoid conflict with our App
            theme,
        } = antd;

        const { Header, Content } = Layout;
        const { Title, Text, Paragraph } = Typography;
        const { Panel } = Collapse;

        const WS_ENDPOINT = 'wss://canvas.marksong.tech:8765';
        const SESSION_STORAGE_KEY = 'canvasWsSession';

        function readStoredSession() {
            if (typeof window === 'undefined' || !window.localStorage) {
                return { key: '', expiry: null };
            }
            try {
                const raw = window.localStorage.getItem(SESSION_STORAGE_KEY);
                if (!raw) {
                    return { key: '', expiry: null };
                }
                const parsed = JSON.parse(raw);
                const key = typeof parsed?.key === 'string' ? parsed.key : '';
                const expiry = typeof parsed?.expiry === 'number' ? parsed.expiry : null;
                if (expiry && expiry <= Date.now()) {
                    window.localStorage.removeItem(SESSION_STORAGE_KEY);
                    return { key: '', expiry: null };
                }
                return { key, expiry };
            } catch (error) {
                console.warn('Failed to read stored session key', error);
                return { key: '', expiry: null };
            }
        }

        function persistSession(key, expiry) {
            if (typeof window === 'undefined' || !window.localStorage) {
                return;
            }
            try {
                if (key) {
                    window.localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify({ key, expiry }));
                } else {
                    window.localStorage.removeItem(SESSION_STORAGE_KEY);
                }
            } catch (error) {
                console.warn('Failed to persist session key', error);
            }
        }

        // Main React Application Component
        function App() {
            // Use AntApp's context for message/notification
            const { message, notification } = AntApp.useApp();

            // --- Session bootstrap ---
            const sessionBootstrap = React.useMemo(() => readStoredSession(), []);

            // --- State Management ---
            const [sessionKey, setSessionKey] = React.useState(sessionBootstrap.key);
            const [sessionExpiry, setSessionExpiry] = React.useState(sessionBootstrap.expiry);
            const [password, setPassword] = React.useState('');
            const [totp, setTotp] = React.useState('');
            const [socket, setSocket] = React.useState(null);
            
            // 'Disconnected', 'Connecting', 'Connected', 'Authenticating', 'Authenticated', 'Error'
            const [status, setStatus] = React.useState('Disconnected');
            const [isAuthenticated, setIsAuthenticated] = React.useState(false);
            
            const [chatQuery, setChatQuery] = React.useState('');
            const [chatHistory, setChatHistory] = React.useState([]); // { role: 'user' | 'agent', text: string }
            const [chatPending, setChatPending] = React.useState(false);
            
            const [courseList, setCourseList] = React.useState([]); // { id, index, name }
            const [isModalVisible, setIsModalVisible] = React.useState(false);
            const [selectedCourseIds, setSelectedCourseIds] = React.useState([]);
            
            const [logEntries, setLogEntries] = React.useState([]); // { time: string, message: string, type: 'system' | 'inbound' | 'outbound' | 'error' }
            const logEndRef = React.useRef(null);
            const chatHistoryEndRef = React.useRef(null);

            React.useEffect(() => {
                persistSession(sessionKey, sessionExpiry);
            }, [sessionKey, sessionExpiry]);

            React.useEffect(() => {
                if (!sessionExpiry) {
                    return;
                }
                if (typeof window === 'undefined') {
                    return;
                }
                const remaining = sessionExpiry - Date.now();
                if (remaining <= 0) {
                    if (sessionKey) {
                        setSessionKey('');
                        setSessionExpiry(null);
                        log('Stored session key expired.', 'system');
                        message.info('Stored session key expired. Please authenticate again.');
                    }
                    return;
                }
                const timer = window.setTimeout(() => {
                    if (sessionKey) {
                        setSessionKey('');
                        setSessionExpiry(null);
                        log('Stored session key expired.', 'system');
                        message.info('Stored session key expired. Please authenticate again.');
                    }
                }, remaining);
                return () => window.clearTimeout(timer);
            }, [sessionExpiry, sessionKey, log, message]);

            // --- Computed State ---
            const isConnected = socket && socket.readyState === WebSocket.OPEN;
            const trimmedPassword = password.trim();
            const trimmedTotp = totp.trim();
            const sessionKeyValid = Boolean(sessionKey && (!sessionExpiry || sessionExpiry > Date.now()));
            const canAttemptConnection = Boolean(trimmedPassword || sessionKeyValid);
            const canChat = isConnected && isAuthenticated && !chatPending;
            const sessionExpiryLabel = React.useMemo(() => {
                if (!sessionKey) {
                    return 'A session key will be stored after successful authentication.';
                }
                if (!sessionExpiry) {
                    return 'Session key active; server did not provide an expiry.';
                }
                if (sessionExpiry <= Date.now()) {
                    return 'Stored session key has expired. Authenticate with password to obtain a new one.';
                }
                return `Session key expires ${new Date(sessionExpiry).toLocaleString()}.`;
            }, [sessionKey, sessionExpiry]);

            // --- Utility Functions ---
            
            /**
             * Adds a new entry to the log state.
             */
            const log = React.useCallback((message, type = 'system') => {
                const timestamp = new Date().toLocaleTimeString();
                setLogEntries(prev => [...prev, { time: timestamp, message, type }]);
            }, []);

            /**
             * Scrolls the log panel to the bottom.
             */
            React.useEffect(() => {
                logEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [logEntries]);
            
            /**
             * Scrolls the chat history to the bottom.
             */
            React.useEffect(() => {
                chatHistoryEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [chatHistory]);

            // --- WebSocket Logic ---

            /**
             * Parses a JSON string safely.
             */
            const safeParseJSON = (text) => {
                try {
                    return JSON.parse(text);
                } catch (error) {
                    log(`Failed to parse JSON: ${text}`, 'error');
                    return null;
                }
            };

            /**
             * Requests the course list from the server.
             */
            const requestCourseList = React.useCallback((sock) => {
                if (!sock || sock.readyState !== WebSocket.OPEN) {
                    log('Socket not open to request course list.', 'error');
                    return;
                }
                const payload = JSON.stringify({ type: 'download' });
                log(`→ ${payload}`, 'outbound');
                sock.send(payload);
            }, [log]);

            const handleAuthentication = React.useCallback((payload, activeSocket) => {
                setIsAuthenticated(true);
                setStatus('Authenticated');
                setPassword('');
                setTotp('');

                const newSessionKey = typeof payload.session_key === 'string' ? payload.session_key : '';
                if (newSessionKey) {
                    if (newSessionKey !== sessionKey) {
                        log('Received new session key from server. Stored for reuse.', 'system');
                    } else {
                        log('Session key refreshed.', 'system');
                    }
                    setSessionKey(newSessionKey);
                }

                if (payload.expires_in !== undefined) {
                    const expiresIn = Number(payload.expires_in);
                    if (Number.isFinite(expiresIn) && expiresIn > 0) {
                        setSessionExpiry(Date.now() + expiresIn * 1000);
                    } else {
                        setSessionExpiry(null);
                    }
                }

                log('Authentication successful. Ready for commands.', 'system');
                notification.success({ message: 'Authentication Successful', description: 'Ready for commands.' });

                if (activeSocket) {
                    requestCourseList(activeSocket);
                }
            }, [log, notification, requestCourseList, sessionKey, setTotp]);
            
            /**
             * Main connection handler.
             */
            const handleConnect = React.useCallback(() => {
                const trimmed = trimmedPassword;
                const usingSession = !trimmed && sessionKeyValid;
                const sessionKeyExpired = !trimmed && Boolean(sessionKey) && !sessionKeyValid;

                if (!trimmed && !usingSession) {
                    if (sessionKeyExpired) {
                        message.warning('Stored session key has expired. Authenticate with your password to obtain a new one.');
                    } else {
                        message.error('Enter the WebSocket password or use an existing session key.');
                    }
                    return;
                }

                log(`Connecting to ${WS_ENDPOINT}...`, 'system');
                setStatus('Connecting');

                try {
                    const newSocket = new WebSocket(WS_ENDPOINT);

                    newSocket.onopen = () => {
                        log('Socket connection established.', 'system');
                        setStatus('Authenticating');

                        const payloadObject = usingSession
                            ? { type: 'auth', session_key: sessionKey }
                            : { type: 'auth', password: trimmed };

                        if (!usingSession && trimmedTotp) {
                            payloadObject.totp = trimmedTotp;
                        }

                        if (usingSession) {
                            log('Authenticating with stored session key.', 'system');
                        } else {
                            log(trimmedTotp ? 'Authenticating with password and provided TOTP.' : 'Authenticating with password (no TOTP provided).', 'system');
                        }

                        const payload = JSON.stringify(payloadObject);
                        log(`→ ${payload}`, 'outbound');
                        newSocket.send(payload);
                    };

                    const handleInbound = (event) => {
                        log(`← ${event.data}`, 'inbound');
                        const payload = safeParseJSON(event.data);
                        if (!payload) return;

                        if (payload.status === 'authenticated') {
                            handleAuthentication(payload, newSocket);
                            return;
                        }

                        if (payload.status === 'course_list') {
                            const courses = payload.courses || [];
                            setCourseList(courses);
                            if (courses.length === 0) {
                                log('Course list is empty.', 'system');
                            } else {
                                const summary = courses
                                    .map(c => `${c.index}. ${c.name || 'Untitled'} (ID: ${c.id})`)
                                    .join('\n');
                                log(`Course roster:\n${summary}`, 'system');
                            }
                            return;
                        }

                        if (typeof payload.answer === 'string') {
                            setChatHistory(prev => [...prev, { role: 'agent', text: payload.answer }]);
                            setChatPending(false);
                            return;
                        }

                        if (payload.error) {
                            log(`Error: ${payload.error}`, 'error');
                            if (typeof payload.error === 'string' && payload.error.toLowerCase().includes('session_key')) {
                                setSessionKey('');
                                setSessionExpiry(null);
                                message.info('Stored session key is no longer valid. Please authenticate with your password.');
                            }
                            notification.error({ message: 'Server Error', description: payload.error });
                            setChatPending(false);
                        }
                    };

                    newSocket.onmessage = handleInbound;

                    newSocket.onclose = (event) => {
                        log(`Connection closed (code ${event.code})`, 'system');
                        setSocket(null);
                        setIsAuthenticated(false);
                        setStatus('Disconnected');
                        setChatPending(false);
                        setCourseList([]);
                    };

                    newSocket.onerror = (event) => {
                        log(`WebSocket error: ${event.message || 'Unknown error'}`, 'error');
                        setStatus('Error');
                        notification.error({ message: 'WebSocket Error', description: 'Check logs for details.'});
                    };

                    setSocket(newSocket);

                } catch (error) {
                    log(`Failed to create WebSocket: ${error}`, 'error');
                    setStatus('Error');
                    notification.error({ message: 'Connection Failed', description: error.message });
                }
            }, [trimmedPassword, trimmedTotp, sessionKey, sessionKeyValid, log, message, notification, handleAuthentication, safeParseJSON]);

            /**
             * Clean up socket connection on unmount.
             */
            React.useEffect(() => {
                return () => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        log('Closing socket connection.', 'system');
                        socket.close(1000, 'Component unmounting');
                    }
                };
            }, [socket, log]);


            // --- UI Event Handlers ---

            const handleSendChat = () => {
                if (!chatQuery.trim()) {
                    message.warning('Please enter a query.');
                    return;
                }
                if (!canChat) {
                    message.error('Not connected or authenticated.');
                    return;
                }

                const payload = JSON.stringify({ type: 'chat', query: chatQuery });
                log(`→ ${payload}`, 'outbound');
                socket.send(payload);
                
                setChatHistory(prev => [...prev, { role: 'user', text: chatQuery }]);
                setChatQuery('');
                setChatPending(true);
            };

            const handleChatPressEnter = (event) => {
                if (event.shiftKey || event.altKey || event.ctrlKey || event.metaKey) {
                    return;
                }
                event.preventDefault();
                handleSendChat();
            };

            const handleSelectCourses = () => {
                if (courseList.length === 0) {
                    message.info('Course list is empty or not yet loaded.');
                    return;
                }
                setSelectedCourseIds([]);
                setIsModalVisible(true);
            };
            
            const handleModalOk = () => {
                if (selectedCourseIds.length === 0) {
                    message.warning('Please select at least one course.');
                    return;
                }

                // Find the full course objects from the IDs
                const selectedCourses = courseList.filter(c => selectedCourseIds.includes(c.id));
                const course_ids = selectedCourses.map(c => c.id);
                const course_indices = selectedCourses.map(c => c.index);

                const payload = JSON.stringify({
                    type: 'download',
                    auto_confirm: true,
                    course_ids,
                    course_indices
                });

                log(`→ ${payload}`, 'outbound');
                socket.send(payload);
                notification.info({ 
                    message: 'Download Started', 
                    description: `Requested download for ${selectedCourseIds.length} course(s).` 
                });

                setIsModalVisible(false);
                setSelectedCourseIds([]);
            };
            
            const handleModalCancel = () => {
                setIsModalVisible(false);
            };
            
            const onCheckboxGroupChange = (checkedValues) => {
                setSelectedCourseIds(checkedValues);
            };

            const handleCopySessionKey = React.useCallback(() => {
                if (!sessionKey) {
                    message.info('No stored session key to copy.');
                    return;
                }
                if (!navigator.clipboard) {
                    message.error('Clipboard API is not available in this browser.');
                    return;
                }
                navigator.clipboard.writeText(sessionKey)
                    .then(() => message.success('Session key copied to clipboard.'))
                    .catch(error => {
                        log(`Clipboard error: ${error}`, 'error');
                        message.error('Failed to copy session key.');
                    });
            }, [sessionKey, message, log]);

            const handleForgetSessionKey = React.useCallback(() => {
                if (!sessionKey) {
                    message.info('No stored session key to clear.');
                    return;
                }
                setSessionKey('');
                setSessionExpiry(null);
                message.success('Stored session key cleared.');
                log('Stored session key cleared by user.', 'system');
            }, [sessionKey, message, log]);

            // --- Log & Chat Renderers ---
            
            const renderStatusTag = () => {
                let color = 'default';
                switch (status) {
                    case 'Authenticated': color = 'success'; break;
                    case 'Connecting':
                    case 'Authenticating':
                        color = 'processing'; break;
                    case 'Connected': color = 'blue'; break;
                    case 'Error': color = 'error'; break;
                    case 'Disconnected': color = 'default'; break;
                }
                return <Tag color={color} className="text-sm">{status}</Tag>;
            };
            
            const renderLogEntry = (entry) => {
                let color;
                switch (entry.type) {
                    case 'system': color = 'text-blue-500'; break;
                    case 'inbound': color = 'text-green-500'; break;
                    case 'outbound': color = 'text-purple-500'; break;
                    case 'error': color = 'text-red-500'; break;
                    default: color = 'text-gray-500';
                }
                return (
                    <div key={`${entry.time}-${entry.message.slice(0, 10)}`} className={`font-mono text-xs ${color} whitespace-pre-wrap`}>
                        <span className="text-gray-400 dark:text-gray-600 mr-2">[{entry.time}]</span>
                        {entry.message}
                    </div>
                );
            };
            
            const renderChatEntry = (entry, index) => (
                <div key={index} className="mb-3">
                    <Text strong>{entry.role === 'agent' ? 'Agent' : 'You'}</Text>
                    <Paragraph className="!mb-0 p-2 bg-gray-100 dark:bg-gray-800 rounded-md whitespace-pre-wrap">
                        {entry.text}
                    </Paragraph>
                </div>
            );
            
            // --- Modal Course Options ---
            const courseOptions = courseList.map(course => ({
                label: (
                    <div className="flex flex-col">
                        <span className="font-medium">{course.name || 'Untitled course'}</span>
                        <small className="text-gray-500">Index: {course.index} • ID: {course.id}</small>
                    </div>
                ),
                value: course.id,
            }));

            // --- Component Render ---
            return (
                <Layout className="min-h-full">
                    <Header className="flex items-center">
                        <Title level={2} className="!text-white !mb-0">Canvas AI Client</Title>
                    </Header>
                    <Content className="p-4 md:p-8">
                        <div className="max-w-4xl mx-auto">
                            <Space direction="vertical" size="large" className="w-full">
                                
                                {/* Connection Panel */}
                                {!isAuthenticated && (
                                    <Card title="Connection">
                                        <Form onFinish={handleConnect} layout="vertical">
                                            <Form.Item
                                                label="Password"
                                                name="password"
                                                extra="Provide your Canvas WebSocket password to create a new session key."
                                            >
                                                <Input.Password 
                                                    placeholder="CANVAS_WS_SECRET"
                                                    value={password}
                                                    onChange={e => setPassword(e.target.value)}
                                                />
                                            </Form.Item>
                                            <Form.Item
                                                label="TOTP Code"
                                                name="totp"
                                                extra="Enter your 6-digit authenticator code when required."
                                            >
                                                <Input
                                                    placeholder="123456"
                                                    value={totp}
                                                    onChange={e => setTotp(e.target.value.replace(/\D/g, ''))}
                                                    maxLength={6}
                                                    inputMode="numeric"
                                                />
                                            </Form.Item>
                                            <Form.Item label="Stored Session Key">
                                                <Space direction="vertical" className="w-full">
                                                    <Input
                                                        value={sessionKey}
                                                        readOnly
                                                        placeholder="No session key stored yet."
                                                    />
                                                    <Space>
                                                        <Button onClick={handleCopySessionKey} disabled={!sessionKey}>
                                                            Copy Session Key
                                                        </Button>
                                                        <Button danger onClick={handleForgetSessionKey} disabled={!sessionKey}>
                                                            Forget Session Key
                                                        </Button>
                                                    </Space>
                                                    <Text type="secondary">{sessionExpiryLabel}</Text>
                                                </Space>
                                            </Form.Item>
                                            <Space className="flex justify-between items-center w-full">
                                                <Button 
                                                    type="primary" 
                                                    htmlType="submit" 
                                                    loading={status === 'Connecting' || status === 'Authenticating'}
                                                    disabled={isConnected || !canAttemptConnection}
                                                >
                                                    {isConnected ? 'Connected' : 'Connect & Authenticate'}
                                                </Button>
                                                {renderStatusTag()}
                                            </Space>
                                        </Form>
                                    </Card>
                                )}
                                
                                {/* Chat Panel */}
                                {isAuthenticated && (
                                    <Card title="Chat">
                                        <Spin spinning={chatPending} tip="Waiting for response...">
                                            <Form onFinish={handleSendChat}>
                                                <Form.Item>
                                                    <Input.TextArea
                                                        rows={4}
                                                        placeholder="e.g. List my Canvas courses"
                                                        value={chatQuery}
                                                        onChange={e => setChatQuery(e.target.value)}
                                                        onPressEnter={handleChatPressEnter}
                                                        disabled={!canChat}
                                                    />
                                                </Form.Item>
                                                <Space>
                                                    <Button type="primary" htmlType="submit" disabled={!canChat}>
                                                        Send Chat
                                                    </Button>
                                                    <Button onClick={handleSelectCourses} disabled={!canChat}>
                                                        Select Courses for Download
                                                    </Button>
                                                </Space>
                                            </Form>
                                        </Spin>
                                        
                                        {/* Chat History */}
                                        {chatHistory.length > 0 && (
                                            <div className="mt-6 p-4 bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-md max-h-96 overflow-y-auto">
                                                {chatHistory.map(renderChatEntry)}
                                                <div ref={chatHistoryEndRef} />
                                            </div>
                                        )}
                                    </Card>
                                )}

                                {/* Log Panel */}
                                {isAuthenticated && (
                                    <Card title="Event Log">
                                        <Collapse ghost>
                                            <Panel header="View Logs" key="1">
                                                <div className="bg-gray-100 dark:bg-gray-900 p-4 rounded-md max-h-80 overflow-y-auto">
                                                    {logEntries.map(renderLogEntry)}
                                                    <div ref={logEndRef} />
                                                </div>
                                            </Panel>
                                        </Collapse>
                                    </Card>
                                )}

                            </Space>
                        </div>
                    </Content>
                    
                    {/* Course Selection Modal */}
                    <Modal
                        title="Select Courses to Download"
                        open={isModalVisible}
                        onOk={handleModalOk}
                        onCancel={handleModalCancel}
                        confirmLoading={!canChat} // Reuse loading state
                        okButtonProps={{ disabled: selectedCourseIds.length === 0 }}
                    >
                        <div className="max-h-80 overflow-y-auto py-2">
                            <Checkbox.Group
                                options={courseOptions}
                                value={selectedCourseIds}
                                onChange={onCheckboxGroupChange}
                                className="w-full"
                            >
                                <Space direction="vertical" className="w-full">
                                    {courseOptions.map(opt => (
                                        <Checkbox key={opt.value} value={opt.value} className="!ml-0 p-2 border border-transparent hover:border-gray-200 dark:hover:border-gray-700 rounded-md w-full">
                                            {opt.label}
                                        </Checkbox>
                                    ))}
                                </Space>
                            </Checkbox.Group>
                        </div>
                    </Modal>
                </Layout>
            );
        }
        
        // --- Theme and App Wrapper ---
        
        const { darkAlgorithm, defaultAlgorithm } = theme;

        function ThemeWrapper() {
            // Detect user's preferred color scheme
            const [isDarkMode, setIsDarkMode] = React.useState(
                window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
            );

            React.useEffect(() => {
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                const handleChange = (e) => setIsDarkMode(e.matches);
                
                mediaQuery.addEventListener('change', handleChange);
                return () => mediaQuery.removeEventListener('change', handleChange);
            }, []);

            return (
                <ConfigProvider 
                    theme={{
                        algorithm: isDarkMode ? darkAlgorithm : defaultAlgorithm,
                    }}
                >
                    {/* AntApp provides context for message/notification */}
                    <AntApp>
                        <App />
                    </AntApp>
                </ConfigProvider>
            );
        }

        // --- Mount the Application ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ThemeWrapper />);
    </script>
</body>
</html>
