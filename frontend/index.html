<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas AI Client</title>
    
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 4. Day.js (Antd Dependency) -->
    <script src="https://unpkg.com/dayjs@1/dayjs.min.js"></script>
    
    <!-- 5. Ant Design (JS & CSS) -->
    <script src="https://unpkg.com/antd@5/dist/antd.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/antd@5/dist/reset.css" />

    <style>
        /* Basic body styling */
        body {
            background-color: #f0f2f5;
        }
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #000;
            }
        }
    </style>
</head>
<body>
    <div id="root" class="h-screen"></div>

    <script type="text/babel">
        // Babel will transpile all code within this script tag

        const {
            Button,
            Card,
            Checkbox,
            Col,
            Collapse,
            ConfigProvider,
            Form,
            Input,
            Layout,
            Modal,
            Row,
            Space,
            Spin,
            Tag,
            Typography,
            App: AntApp, // Renamed to avoid conflict with our App
            theme,
        } = antd;

        const { Header, Content } = Layout;
        const { Title, Text, Paragraph } = Typography;
        const { Panel } = Collapse;

        const WS_ENDPOINT = 'wss://canvas.marksong.tech:8765';
        const SESSION_DURATION_MINUTES = 10; // Should match server SESSION_DURATION

        // Main React Application Component
        function App() {
            // Use AntApp's context for message/notification
            const { message, notification } = AntApp.useApp();

            // --- State Management ---
            const [socket, setSocket] = React.useState(null);
            
            // 'Disconnected', 'Connecting', 'Connected', 'Error'
            const [status, setStatus] = React.useState('Disconnected');
            const [retryCount, setRetryCount] = React.useState(0);
            const [connectionStartTime, setConnectionStartTime] = React.useState(null);
            const [sessionTimeRemaining, setSessionTimeRemaining] = React.useState(null);
            
            const [chatQuery, setChatQuery] = React.useState('');
            const [chatHistory, setChatHistory] = React.useState([]); // { role: 'user' | 'agent', text: string }
            const [chatPending, setChatPending] = React.useState(false);
            
            const [courseList, setCourseList] = React.useState([]); // { id, index, name }
            const [isModalVisible, setIsModalVisible] = React.useState(false);
            const [selectedCourseIds, setSelectedCourseIds] = React.useState([]);
            
            const [logEntries, setLogEntries] = React.useState([]); // { time: string, message: string, type: 'system' | 'inbound' | 'outbound' | 'error' }
            const logEndRef = React.useRef(null);
            const chatHistoryEndRef = React.useRef(null);
            const retryTimeoutRef = React.useRef(null);
            const sessionTimerRef = React.useRef(null);

            // --- Computed State ---
            const isConnected = socket && socket.readyState === WebSocket.OPEN;
            const canChat = isConnected && !chatPending;

            // --- Session Timer Effect ---
            React.useEffect(() => {
                if (!connectionStartTime) {
                    setSessionTimeRemaining(null);
                    return;
                }

                const updateTimer = () => {
                    const elapsed = Date.now() - connectionStartTime;
                    const remaining = (SESSION_DURATION_MINUTES * 60 * 1000) - elapsed;
                    
                    if (remaining <= 0) {
                        setSessionTimeRemaining(0);
                        if (sessionTimerRef.current) {
                            clearInterval(sessionTimerRef.current);
                            sessionTimerRef.current = null;
                        }
                        return;
                    }
                    
                    setSessionTimeRemaining(remaining);
                };

                updateTimer();
                sessionTimerRef.current = setInterval(updateTimer, 1000);

                return () => {
                    if (sessionTimerRef.current) {
                        clearInterval(sessionTimerRef.current);
                        sessionTimerRef.current = null;
                    }
                };
            }, [connectionStartTime]);

            // --- Format time remaining ---
            const formatTimeRemaining = React.useCallback((milliseconds) => {
                if (milliseconds === null) return '';
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, []);

            // --- Utility Functions ---
            
            /**
             * Adds a new entry to the log state.
             */
            const log = React.useCallback((message, type = 'system') => {
                const timestamp = new Date().toLocaleTimeString();
                setLogEntries(prev => [...prev, { time: timestamp, message, type }]);
            }, []);

            /**
             * Scrolls the log panel to the bottom.
             */
            React.useEffect(() => {
                logEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [logEntries]);
            
            /**
             * Scrolls the chat history to the bottom.
             */
            React.useEffect(() => {
                chatHistoryEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [chatHistory]);

            // --- WebSocket Logic ---

            /**
             * Parses a JSON string safely.
             */
            const safeParseJSON = (text) => {
                try {
                    return JSON.parse(text);
                } catch (error) {
                    log(`Failed to parse JSON: ${text}`, 'error');
                    return null;
                }
            };

            /**
             * Requests the course list from the server.
             */
            const requestCourseList = React.useCallback((sock) => {
                if (!sock || sock.readyState !== WebSocket.OPEN) {
                    log('Socket not open to request course list.', 'error');
                    return;
                }
                const payload = JSON.stringify({ type: 'download' });
                log(`→ ${payload}`, 'outbound');
                sock.send(payload);
            }, [log]);

            /**
             * Main connection handler with auto-retry.
             */
            const handleConnect = React.useCallback(() => {
                // Clear any pending retry
                if (retryTimeoutRef.current) {
                    clearTimeout(retryTimeoutRef.current);
                    retryTimeoutRef.current = null;
                }

                log(`Connecting to ${WS_ENDPOINT}... (attempt ${retryCount + 1})`, 'system');
                setStatus('Connecting');

                try {
                    const newSocket = new WebSocket(WS_ENDPOINT);

                    newSocket.onopen = () => {
                        log('Connected to server.', 'system');
                        setStatus('Connected');
                        setRetryCount(0);
                        setConnectionStartTime(Date.now());
                        
                        // Request course list on connection
                        requestCourseList(newSocket);
                    };

                    const handleInbound = (event) => {
                        log(`← ${event.data}`, 'inbound');
                        const payload = safeParseJSON(event.data);
                        if (!payload) return;

                        if (payload.status === 'course_list') {
                            const courses = payload.courses || [];
                            setCourseList(courses);
                            if (courses.length === 0) {
                                log('Course list is empty.', 'system');
                            } else {
                                const summary = courses
                                    .map(c => `${c.index}. ${c.name || 'Untitled'} (ID: ${c.id})`)
                                    .join('\n');
                                log(`Course roster:\n${summary}`, 'system');
                            }
                            return;
                        }

                        if (typeof payload.answer === 'string') {
                            setChatHistory(prev => [...prev, { role: 'agent', text: payload.answer }]);
                            setChatPending(false);
                            return;
                        }

                        if (payload.error) {
                            log(`Error: ${payload.error}`, 'error');
                            notification.error({ message: 'Server Error', description: payload.error });
                            setChatPending(false);
                        }
                    };

                    newSocket.onmessage = handleInbound;

                    newSocket.onclose = (event) => {
                        log(`Connection closed (code ${event.code})`, 'system');
                        setSocket(null);
                        setStatus('Disconnected');
                        setChatPending(false);
                        setCourseList([]);
                        setConnectionStartTime(null);
                        
                        // Schedule retry
                        const delay = Math.min(5000, 1000 * Math.pow(1.5, retryCount));
                        log(`Reconnecting in ${Math.round(delay / 1000)}s...`, 'system');
                        setRetryCount(prev => prev + 1);
                        retryTimeoutRef.current = setTimeout(() => {
                            handleConnect();
                        }, delay);
                    };

                    newSocket.onerror = (event) => {
                        log(`WebSocket error: ${event.message || 'Connection failed'}`, 'error');
                        setStatus('Error');
                    };

                    setSocket(newSocket);

                } catch (error) {
                    log(`Failed to create WebSocket: ${error}`, 'error');
                    setStatus('Error');
                    
                    // Schedule retry on exception
                    const delay = Math.min(5000, 1000 * Math.pow(1.5, retryCount));
                    setRetryCount(prev => prev + 1);
                    retryTimeoutRef.current = setTimeout(() => {
                        handleConnect();
                    }, delay);
                }
            }, [log, requestCourseList, safeParseJSON, notification, retryCount]);

            /**
             * Clean up socket connection on unmount.
             */
            React.useEffect(() => {
                return () => {
                    if (retryTimeoutRef.current) {
                        clearTimeout(retryTimeoutRef.current);
                    }
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        log('Closing socket connection.', 'system');
                        socket.close(1000, 'Component unmounting');
                    }
                };
            }, [socket, log]);

            /**
             * Auto-connect on mount.
             */
            React.useEffect(() => {
                handleConnect();
            }, []);


            // --- UI Event Handlers ---

            const handleSendChat = () => {
                if (!chatQuery.trim()) {
                    message.warning('Please enter a query.');
                    return;
                }
                if (!canChat) {
                    message.error('Not connected or authenticated.');
                    return;
                }

                const payload = JSON.stringify({ type: 'chat', query: chatQuery });
                log(`→ ${payload}`, 'outbound');
                socket.send(payload);
                
                setChatHistory(prev => [...prev, { role: 'user', text: chatQuery }]);
                setChatQuery('');
                setChatPending(true);
            };

            const handleChatPressEnter = (event) => {
                if (event.shiftKey || event.altKey || event.ctrlKey || event.metaKey) {
                    return;
                }
                event.preventDefault();
                handleSendChat();
            };

            const handleSelectCourses = () => {
                if (courseList.length === 0) {
                    message.info('Course list is empty or not yet loaded.');
                    return;
                }
                setSelectedCourseIds([]);
                setIsModalVisible(true);
            };
            
            const handleModalOk = () => {
                if (selectedCourseIds.length === 0) {
                    message.warning('Please select at least one course.');
                    return;
                }

                // Find the full course objects from the IDs
                const selectedCourses = courseList.filter(c => selectedCourseIds.includes(c.id));
                const course_ids = selectedCourses.map(c => c.id);
                const course_indices = selectedCourses.map(c => c.index);

                const payload = JSON.stringify({
                    type: 'download',
                    auto_confirm: true,
                    course_ids,
                    course_indices
                });

                log(`→ ${payload}`, 'outbound');
                socket.send(payload);
                notification.info({ 
                    message: 'Download Started', 
                    description: `Requested download for ${selectedCourseIds.length} course(s).` 
                });

                setIsModalVisible(false);
                setSelectedCourseIds([]);
            };
            
            const handleModalCancel = () => {
                setIsModalVisible(false);
            };
            
            const onCheckboxGroupChange = (checkedValues) => {
                setSelectedCourseIds(checkedValues);
            };

            // --- Log & Chat Renderers ---
            
            const renderStatusTag = () => {
                let color = 'default';
                switch (status) {
                    case 'Connected': color = 'success'; break;
                    case 'Connecting': color = 'processing'; break;
                    case 'Error': color = 'error'; break;
                    case 'Disconnected': color = 'warning'; break;
                }
                return <Tag color={color} className="text-sm">{status}</Tag>;
            };
            
            const renderLogEntry = (entry) => {
                let color;
                switch (entry.type) {
                    case 'system': color = 'text-blue-500'; break;
                    case 'inbound': color = 'text-green-500'; break;
                    case 'outbound': color = 'text-purple-500'; break;
                    case 'error': color = 'text-red-500'; break;
                    default: color = 'text-gray-500';
                }
                return (
                    <div key={`${entry.time}-${entry.message.slice(0, 10)}`} className={`font-mono text-xs ${color} whitespace-pre-wrap`}>
                        <span className="text-gray-400 dark:text-gray-600 mr-2">[{entry.time}]</span>
                        {entry.message}
                    </div>
                );
            };
            
            const renderChatEntry = (entry, index) => (
                <div key={index} className="mb-3">
                    <Text strong>{entry.role === 'agent' ? 'Agent' : 'You'}</Text>
                    <Paragraph className="!mb-0 p-2 bg-gray-100 dark:bg-gray-800 rounded-md whitespace-pre-wrap">
                        {entry.text}
                    </Paragraph>
                </div>
            );
            
            // --- Modal Course Options ---
            const courseOptions = courseList.map(course => ({
                label: (
                    <div className="flex flex-col">
                        <span className="font-medium">{course.name || 'Untitled course'}</span>
                        <small className="text-gray-500">Index: {course.index} • ID: {course.id}</small>
                    </div>
                ),
                value: course.id,
            }));

            // --- Component Render ---
            return (
                <Layout className="min-h-full">
                    <Header className="flex items-center" style={{ backgroundColor: '#204560' }}>
                        <Title level={2} className="!text-white !mb-0">Canvas AI Client</Title>
                        <div className="ml-auto flex items-center gap-4">
                            {sessionTimeRemaining !== null && (
                                <div className="flex items-center gap-2">
                                    <Text className="!text-white text-sm">
                                        Session: {formatTimeRemaining(sessionTimeRemaining)}
                                    </Text>
                                    {sessionTimeRemaining < 5 * 60 * 1000 && sessionTimeRemaining > 0 && (
                                        <Tag color="warning" className="!mb-0">
                                            Expiring Soon
                                        </Tag>
                                    )}
                                </div>
                            )}
                            <a 
                                href="https://github.com/MarkSong535/canvas_ai" 
                                target="_blank" 
                                rel="noopener noreferrer"
                                className="flex items-center gap-2 text-white hover:text-gray-300 transition-colors"
                            >
                                <svg height="24" width="24" viewBox="0 0 98 96" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                                    <path fillRule="evenodd" clipRule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z"/>
                                </svg>
                                <span className="text-sm">GitHub</span>
                            </a>
                            {renderStatusTag()}
                        </div>
                    </Header>
                    <Content className="p-4 md:p-8">
                        <div className="max-w-4xl mx-auto">
                            <Space direction="vertical" size="large" className="w-full">
                                
                                {/* Chat Panel */}
                                <Card title="Chat">
                                    <Spin spinning={chatPending} tip="Waiting for response...">
                                        <Form onFinish={handleSendChat}>
                                            <Form.Item>
                                                <Input.TextArea
                                                    rows={4}
                                                    placeholder="e.g. List my Canvas courses"
                                                    value={chatQuery}
                                                    onChange={e => setChatQuery(e.target.value)}
                                                    onPressEnter={handleChatPressEnter}
                                                    disabled={!canChat}
                                                />
                                            </Form.Item>
                                            <Space>
                                                <Button type="primary" htmlType="submit" disabled={!canChat}>
                                                    Send Chat
                                                </Button>
                                                <Button onClick={handleSelectCourses} disabled={!canChat}>
                                                    Select Courses for Download
                                                </Button>
                                            </Space>
                                        </Form>
                                    </Spin>
                                    
                                    {/* Chat History */}
                                    {chatHistory.length > 0 && (
                                        <div className="mt-6 p-4 bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-md max-h-96 overflow-y-auto">
                                            {chatHistory.map(renderChatEntry)}
                                            <div ref={chatHistoryEndRef} />
                                        </div>
                                    )}
                                </Card>

                                {/* Log Panel */}
                                <Card title="Event Log">
                                    <Collapse ghost>
                                        <Panel header="View Logs" key="1">
                                            <div className="bg-gray-100 dark:bg-gray-900 p-4 rounded-md max-h-80 overflow-y-auto">
                                                {logEntries.map(renderLogEntry)}
                                                <div ref={logEndRef} />
                                            </div>
                                        </Panel>
                                    </Collapse>
                                </Card>

                            </Space>
                        </div>
                    </Content>
                    
                    {/* Course Selection Modal */}
                    <Modal
                        title="Select Courses to Download"
                        open={isModalVisible}
                        onOk={handleModalOk}
                        onCancel={handleModalCancel}
                        confirmLoading={!canChat} // Reuse loading state
                        okButtonProps={{ disabled: selectedCourseIds.length === 0 }}
                    >
                        <div className="max-h-80 overflow-y-auto py-2">
                            <Checkbox.Group
                                options={courseOptions}
                                value={selectedCourseIds}
                                onChange={onCheckboxGroupChange}
                                className="w-full"
                            >
                                <Space direction="vertical" className="w-full">
                                    {courseOptions.map(opt => (
                                        <Checkbox key={opt.value} value={opt.value} className="!ml-0 p-2 border border-transparent hover:border-gray-200 dark:hover:border-gray-700 rounded-md w-full">
                                            {opt.label}
                                        </Checkbox>
                                    ))}
                                </Space>
                            </Checkbox.Group>
                        </div>
                    </Modal>
                </Layout>
            );
        }
        
        // --- Theme and App Wrapper ---
        
        const { darkAlgorithm, defaultAlgorithm } = theme;

        function ThemeWrapper() {
            // Detect user's preferred color scheme
            const [isDarkMode, setIsDarkMode] = React.useState(
                window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
            );

            React.useEffect(() => {
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                const handleChange = (e) => setIsDarkMode(e.matches);
                
                mediaQuery.addEventListener('change', handleChange);
                return () => mediaQuery.removeEventListener('change', handleChange);
            }, []);

            return (
                <ConfigProvider 
                    theme={{
                        algorithm: isDarkMode ? darkAlgorithm : defaultAlgorithm,
                    }}
                >
                    {/* AntApp provides context for message/notification */}
                    <AntApp>
                        <App />
                    </AntApp>
                </ConfigProvider>
            );
        }

        // --- Mount the Application ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ThemeWrapper />);
    </script>
</body>
</html>
