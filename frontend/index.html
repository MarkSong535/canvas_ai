<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas AI Client</title>
    
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 4. Day.js (Antd Dependency) -->
    <script src="https://unpkg.com/dayjs@1/dayjs.min.js"></script>
    
    <!-- 5. Ant Design (JS & CSS) -->
    <script src="https://unpkg.com/antd@5/dist/antd.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/antd@5/dist/reset.css" />

    <style>
        /* Basic body styling */
        body {
            background-color: #f0f2f5;
        }
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #000;
            }
        }
    </style>
</head>
<body>
    <div id="root" class="h-screen"></div>

    <script type="text/babel">
        // Babel will transpile all code within this script tag

        const {
            Button,
            Card,
            Checkbox,
            Col,
            Collapse,
            ConfigProvider,
            Form,
            Input,
            Layout,
            Modal,
            Row,
            Space,
            Spin,
            Tag,
            Typography,
            App: AntApp, // Renamed to avoid conflict with our App
            theme,
        } = antd;

        const { Header, Content } = Layout;
        const { Title, Text, Paragraph } = Typography;
        const { Panel } = Collapse;

        const WS_ENDPOINT = 'wss://canvas.marksong.tech:8765';

        // Main React Application Component
        function App() {
            // Use AntApp's context for message/notification
            const { message, notification } = AntApp.useApp();

            // --- State Management ---
            const [password, setPassword] = React.useState('');
            const [socket, setSocket] = React.useState(null);
            
            // 'Disconnected', 'Connecting', 'Connected', 'Authenticating', 'Authenticated', 'Error'
            const [status, setStatus] = React.useState('Disconnected');
            const [isAuthenticated, setIsAuthenticated] = React.useState(false);
            
            const [chatQuery, setChatQuery] = React.useState('');
            const [chatHistory, setChatHistory] = React.useState([]); // { role: 'user' | 'agent', text: string }
            const [chatPending, setChatPending] = React.useState(false);
            
            const [courseList, setCourseList] = React.useState([]); // { id, index, name }
            const [isModalVisible, setIsModalVisible] = React.useState(false);
            const [selectedCourseIds, setSelectedCourseIds] = React.useState([]);
            
            const [logEntries, setLogEntries] = React.useState([]); // { time: string, message: string, type: 'system' | 'inbound' | 'outbound' | 'error' }
            const logEndRef = React.useRef(null);
            const chatHistoryEndRef = React.useRef(null);

            // --- Computed State ---
            const isConnected = socket && socket.readyState === WebSocket.OPEN;
            const canChat = isConnected && isAuthenticated && !chatPending;

            // --- Utility Functions ---
            
            /**
             * Adds a new entry to the log state.
             */
            const log = React.useCallback((message, type = 'system') => {
                const timestamp = new Date().toLocaleTimeString();
                setLogEntries(prev => [...prev, { time: timestamp, message, type }]);
            }, []);

            /**
             * Scrolls the log panel to the bottom.
             */
            React.useEffect(() => {
                logEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [logEntries]);
            
            /**
             * Scrolls the chat history to the bottom.
             */
            React.useEffect(() => {
                chatHistoryEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [chatHistory]);

            // --- WebSocket Logic ---

            /**
             * Parses a JSON string safely.
             */
            const safeParseJSON = (text) => {
                try {
                    return JSON.parse(text);
                } catch (error) {
                    log(`Failed to parse JSON: ${text}`, 'error');
                    return null;
                }
            };

            /**
             * Requests the course list from the server.
             */
            const requestCourseList = React.useCallback((sock) => {
                if (!sock || sock.readyState !== WebSocket.OPEN) {
                    log('Socket not open to request course list.', 'error');
                    return;
                }
                const payload = JSON.stringify({ type: 'download' });
                log(`→ ${payload}`, 'outbound');
                sock.send(payload);
            }, [log]);
            
            /**
             * Handles all inbound WebSocket messages.
             */
            const handleInboundMessage = React.useCallback((event) => {
                log(`← ${event.data}`, 'inbound');
                const payload = safeParseJSON(event.data);
                if (!payload) return;

                if (payload.status === 'authenticated') {
                    setIsAuthenticated(true);
                    setStatus('Authenticated');
                    log('Authentication successful. Ready for commands.', 'system');
                    notification.success({ message: 'Authentication Successful', description: 'Ready for commands.' });
                    // 'socket' from state might be stale here, so we use the one from connect
                    // This function is defined inside handleConnect, so it has access to `newSocket`.
                    // A better way is to pass socket as an arg.
                    // Re-fetching handleConnect to pass the socket instance...
                    
                    // Note: This function will be redefined inside handleConnect
                    // to close over the `newSocket` instance.
                }

                if (payload.status === 'course_list') {
                    const courses = payload.courses || [];
                    setCourseList(courses);
                    if (courses.length === 0) {
                        log('Course list is empty.', 'system');
                    } else {
                        const summary = courses
                            .map(c => `${c.index}. ${c.name || 'Untitled'} (ID: ${c.id})`)
                            .join('\n');
                        log(`Course roster:\n${summary}`, 'system');
                    }
                }

                if (typeof payload.answer === 'string') {
                    setChatHistory(prev => [...prev, { role: 'agent', text: payload.answer }]);
                    setChatPending(false);
                }

                if (payload.error) {
                    log(`Error: ${payload.error}`, 'error');
                    notification.error({ message: 'Server Error', description: payload.error });
                    setChatPending(false);
                }
            }, [log, notification]);


            /**
             * Main connection handler.
             */
            const handleConnect = React.useCallback(() => {
                if (!password) {
                    message.error('Please enter the WebSocket password.');
                    return;
                }
                
                log(`Connecting to ${WS_ENDPOINT}...`, 'system');
                setStatus('Connecting');
                
                try {
                    const newSocket = new WebSocket(WS_ENDPOINT);

                    newSocket.onopen = () => {
                        log('Socket connection established.', 'system');
                        setStatus('Authenticating');
                        
                        // Send auth
                        const payload = JSON.stringify({
                            type: 'auth',
                            password,
                            totp: '000000'
                        });
                        log(`→ ${payload}`, 'outbound');
                        newSocket.send(payload);
                    };

                    // Redefine handleInboundMessage to close over newSocket
                    const handleInbound = (event) => {
                        log(`← ${event.data}`, 'inbound');
                        const payload = safeParseJSON(event.data);
                        if (!payload) return;

                        if (payload.status === 'authenticated') {
                            setIsAuthenticated(true);
                            setStatus('Authenticated');
                            log('Authentication successful. Ready for commands.', 'system');
                            notification.success({ message: 'Authentication Successful', description: 'Ready for commands.' });
                            requestCourseList(newSocket); // Use the newSocket instance
                        }

                        if (payload.status === 'course_list') {
                            const courses = payload.courses || [];
                            setCourseList(courses);
                            if (courses.length === 0) {
                                log('Course list is empty.', 'system');
                            } else {
                                const summary = courses
                                    .map(c => `${c.index}. ${c.name || 'Untitled'} (ID: ${c.id})`)
                                    .join('\n');
                                log(`Course roster:\n${summary}`, 'system');
                            }
                        }

                        if (typeof payload.answer === 'string') {
                            setChatHistory(prev => [...prev, { role: 'agent', text: payload.answer }]);
                            setChatPending(false);
                        }

                        if (payload.error) {
                            log(`Error: ${payload.error}`, 'error');
                            notification.error({ message: 'Server Error', description: payload.error });
                            setChatPending(false);
                        }
                    };
                    
                    newSocket.onmessage = handleInbound;

                    newSocket.onclose = (event) => {
                        log(`Connection closed (code ${event.code})`, 'system');
                        setSocket(null);
                        setIsAuthenticated(false);
                        setStatus('Disconnected');
                        setChatPending(false);
                        setCourseList([]);
                    };

                    newSocket.onerror = (event) => {
                        log(`WebSocket error: ${event.message || 'Unknown error'}`, 'error');
                        setStatus('Error');
                        notification.error({ message: 'WebSocket Error', description: 'Check logs for details.'});
                    };
                    
                    setSocket(newSocket);

                } catch (error) {
                    log(`Failed to create WebSocket: ${error}`, 'error');
                    setStatus('Error');
                    notification.error({ message: 'Connection Failed', description: error.message });
                }
            }, [password, log, notification, requestCourseList]);

            /**
             * Clean up socket connection on unmount.
             */
            React.useEffect(() => {
                return () => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        log('Closing socket connection.', 'system');
                        socket.close(1000, 'Component unmounting');
                    }
                };
            }, [socket, log]);


            // --- UI Event Handlers ---

            const handleSendChat = () => {
                if (!chatQuery.trim()) {
                    message.warning('Please enter a query.');
                    return;
                }
                if (!canChat) {
                    message.error('Not connected or authenticated.');
                    return;
                }

                const payload = JSON.stringify({ type: 'chat', query: chatQuery });
                log(`→ ${payload}`, 'outbound');
                socket.send(payload);
                
                setChatHistory(prev => [...prev, { role: 'user', text: chatQuery }]);
                setChatQuery('');
                setChatPending(true);
            };

            const handleSelectCourses = () => {
                if (courseList.length === 0) {
                    message.info('Course list is empty or not yet loaded.');
                    return;
                }
                setSelectedCourseIds([]);
                setIsModalVisible(true);
            };
            
            const handleModalOk = () => {
                if (selectedCourseIds.length === 0) {
                    message.warning('Please select at least one course.');
                    return;
                }

                // Find the full course objects from the IDs
                const selectedCourses = courseList.filter(c => selectedCourseIds.includes(c.id));
                const course_ids = selectedCourses.map(c => c.id);
                const course_indices = selectedCourses.map(c => c.index);

                const payload = JSON.stringify({
                    type: 'download',
                    auto_confirm: true,
                    course_ids,
                    course_indices
                });

                log(`→ ${payload}`, 'outbound');
                socket.send(payload);
                notification.info({ 
                    message: 'Download Started', 
                    description: `Requested download for ${selectedCourseIds.length} course(s).` 
                });

                setIsModalVisible(false);
                setSelectedCourseIds([]);
            };
            
            const handleModalCancel = () => {
                setIsModalVisible(false);
            };
            
            const onCheckboxGroupChange = (checkedValues) => {
                setSelectedCourseIds(checkedValues);
            };

            // --- Log & Chat Renderers ---
            
            const renderStatusTag = () => {
                let color = 'default';
                switch (status) {
                    case 'Authenticated': color = 'success'; break;
                    case 'Connecting':
                    case 'Authenticating':
                        color = 'processing'; break;
                    case 'Connected': color = 'blue'; break;
                    case 'Error': color = 'error'; break;
                    case 'Disconnected': color = 'default'; break;
                }
                return <Tag color={color} className="text-sm">{status}</Tag>;
            };
            
            const renderLogEntry = (entry) => {
                let color;
                switch (entry.type) {
                    case 'system': color = 'text-blue-500'; break;
                    case 'inbound': color = 'text-green-500'; break;
                    case 'outbound': color = 'text-purple-500'; break;
                    case 'error': color = 'text-red-500'; break;
                    default: color = 'text-gray-500';
                }
                return (
                    <div key={`${entry.time}-${entry.message.slice(0, 10)}`} className={`font-mono text-xs ${color} whitespace-pre-wrap`}>
                        <span className="text-gray-400 dark:text-gray-600 mr-2">[{entry.time}]</span>
                        {entry.message}
                    </div>
                );
            };
            
            const renderChatEntry = (entry, index) => (
                <div key={index} className="mb-3">
                    <Text strong>{entry.role === 'agent' ? 'Agent' : 'You'}</Text>
                    <Paragraph className="!mb-0 p-2 bg-gray-100 dark:bg-gray-800 rounded-md whitespace-pre-wrap">
                        {entry.text}
                    </Paragraph>
                </div>
            );
            
            // --- Modal Course Options ---
            const courseOptions = courseList.map(course => ({
                label: (
                    <div className="flex flex-col">
                        <span className="font-medium">{course.name || 'Untitled course'}</span>
                        <small className="text-gray-500">Index: {course.index} • ID: {course.id}</small>
                    </div>
                ),
                value: course.id,
            }));

            // --- Component Render ---
            return (
                <Layout className="min-h-full">
                    <Header className="flex items-center">
                        <Title level={2} className="!text-white !mb-0">Canvas AI Client</Title>
                    </Header>
                    <Content className="p-4 md:p-8">
                        <div className="max-w-4xl mx-auto">
                            <Space direction="vertical" size="large" className="w-full">
                                
                                {/* Connection Panel */}
                                {!isAuthenticated && (
                                    <Card title="Connection">
                                        <Form onFinish={handleConnect}>
                                            <Form.Item
                                                label="Password"
                                                name="password"
                                                rules={[{ required: true, message: 'Password is required' }]}
                                            >
                                                <Input.Password 
                                                    placeholder="CANVAS_WS_SECRET"
                                                    value={password}
                                                    onChange={e => setPassword(e.target.value)}
                                                />
                                            </Form.Item>
                                            <Space className="flex justify-between items-center w-full">
                                                <Button 
                                                    type="primary" 
                                                    htmlType="submit" 
                                                    loading={status === 'Connecting' || status === 'Authenticating'}
                                                    disabled={isConnected}
                                                >
                                                    {isConnected ? 'Connected' : 'Connect & Authenticate'}
                                                </Button>
                                                {renderStatusTag()}
                                            </Space>
                                        </Form>
                                    </Card>
                                )}
                                
                                {/* Chat Panel */}
                                {isAuthenticated && (
                                    <Card title="Chat">
                                        <Spin spinning={chatPending} tip="Waiting for response...">
                                            <Form onFinish={handleSendChat}>
                                                <Form.Item>
                                                    <Input.TextArea
                                                        rows={4}
                                                        placeholder="e.g. List my Canvas courses"
                                                        value={chatQuery}
                                                        onChange={e => setChatQuery(e.target.value)}
                                                        disabled={!canChat}
                                                    />
                                                </Form.Item>
                                                <Space>
                                                    <Button type="primary" htmlType="submit" disabled={!canChat}>
                                                        Send Chat
                                                    </Button>
                                                    <Button onClick={handleSelectCourses} disabled={!canChat}>
                                                        Select Courses for Download
                                                    </Button>
                                                </Space>
                                            </Form>
                                        </Spin>
                                        
                                        {/* Chat History */}
                                        {chatHistory.length > 0 && (
                                            <div className="mt-6 p-4 bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-md max-h-96 overflow-y-auto">
                                                {chatHistory.map(renderChatEntry)}
                                                <div ref={chatHistoryEndRef} />
                                            </div>
                                        )}
                                    </Card>
                                )}

                                {/* Log Panel */}
                                {isAuthenticated && (
                                    <Card title="Event Log">
                                        <Collapse ghost>
                                            <Panel header="View Logs" key="1">
                                                <div className="bg-gray-100 dark:bg-gray-900 p-4 rounded-md max-h-80 overflow-y-auto">
                                                    {logEntries.map(renderLogEntry)}
                                                    <div ref={logEndRef} />
                                                </div>
                                            </Panel>
                                        </Collapse>
                                    </Card>
                                )}

                            </Space>
                        </div>
                    </Content>
                    
                    {/* Course Selection Modal */}
                    <Modal
                        title="Select Courses to Download"
                        open={isModalVisible}
                        onOk={handleModalOk}
                        onCancel={handleModalCancel}
                        confirmLoading={!canChat} // Reuse loading state
                        okButtonProps={{ disabled: selectedCourseIds.length === 0 }}
                    >
                        <div className="max-h-80 overflow-y-auto py-2">
                            <Checkbox.Group
                                options={courseOptions}
                                value={selectedCourseIds}
                                onChange={onCheckboxGroupChange}
                                className="w-full"
                            >
                                <Space direction="vertical" className="w-full">
                                    {courseOptions.map(opt => (
                                        <Checkbox key={opt.value} value={opt.value} className="!ml-0 p-2 border border-transparent hover:border-gray-200 dark:hover:border-gray-700 rounded-md w-full">
                                            {opt.label}
                                        </Checkbox>
                                    ))}
                                </Space>
                            </Checkbox.Group>
                        </div>
                    </Modal>
                </Layout>
            );
        }
        
        // --- Theme and App Wrapper ---
        
        const { darkAlgorithm, defaultAlgorithm } = theme;

        function ThemeWrapper() {
            // Detect user's preferred color scheme
            const [isDarkMode, setIsDarkMode] = React.useState(
                window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
            );

            React.useEffect(() => {
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                const handleChange = (e) => setIsDarkMode(e.matches);
                
                mediaQuery.addEventListener('change', handleChange);
                return () => mediaQuery.removeEventListener('change', handleChange);
            }, []);

            return (
                <ConfigProvider 
                    theme={{
                        algorithm: isDarkMode ? darkAlgorithm : defaultAlgorithm,
                    }}
                >
                    {/* AntApp provides context for message/notification */}
                    <AntApp>
                        <App />
                    </AntApp>
                </ConfigProvider>
            );
        }

        // --- Mount the Application ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ThemeWrapper />);
    </script>
</body>
</html>
